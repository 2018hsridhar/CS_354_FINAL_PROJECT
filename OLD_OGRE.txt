#include <dirent.h>

#include "bones.h"
#include <algorithm>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_access.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/component_wise.hpp>
#include <glm/gtx/rotate_vector.hpp>
#include <glm/gtx/string_cast.hpp>
#include <jpeglib.h>

// interleaved RGB image struct RGB RGB RGB, row major:
// RGBRGBRGB
// RGBRGBRGB
// RGBRGBRGB
// above: example 3 x 3 image.
// 8 bits per channel.

struct Image {
  unsigned char* bytes;
  int width;
  int height;
};

int window_width = 800, window_height = 600;
const std::string window_title = "Virtual Mannequin";
const float kNear = 0.0001f;
const float kFar = 1000.0f;
const float kFov = 45.0f;
float aspect = static_cast<float>(window_width) / window_height;

// Floor
const float eps = 0.5 * (0.025 + 0.0175);
const float kFloorXMin = -100.0f;
const float kFloorXMax = 100.0f;
const float kFloorZMin = -100.0f;
const float kFloorZMax = 100.0f;
const float kFloorY = -0.75617 - eps;

// Skeleton
const Skeleton skeleton = Skeleton(
	"ogre-rigged/ogre-skeleton.bf", 
	"ogre-rigged/ogre-weights.dmat");
const glm::vec4 skeleton_color = glm::vec4(1.0, 1.0, 1.0, 1.0);
std::vector<glm::vec4> skeleton_vertices;
std::vector<glm::uvec2> skeleton_indices;
int ogre_texture = 0;

// Cylinder
const float kCylinderRadius = 0.05f;
int bone_hit_idx = -1;

// Mouse
int current_mouse_mode = 0;
enum {
 	kMouseModeCamera,
  	kMouseModeSkeleton,
  	kNumMouseModes
};


// VBO and VAO
enum {
  	kVertexBuffer,
  	kIndexBuffer,
	kUndeformedBuffer,
  	kVertexNormalBuffer,
	kNumVbos
};

enum {
  	kFloorVao,
	kSkeletonVao,
	kOgreVao,
	kCylinderVao,
 	kNumVaos
};

GLuint array_objects[kNumVaos];  			// Store VAO descriptors
GLuint buffer_objects[kNumVaos][kNumVbos];  // Store VBO descriptors

float last_x = 0.0f, last_y = 0.0f, current_x = 0.0f, current_y = 0.0f;
bool drag_state = false;
int current_button = -1;
float camera_distance = 2.0;
float pan_speed = 0.1f;
float roll_speed = 0.1f;
float rotation_speed = 0.05f;
float zoom_speed = 0.1f;
glm::vec3 eye = glm::vec3(0.0f, 0.1f, camera_distance);
glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
glm::vec3 look = glm::vec3(0.0f, 0.0f, 1.0f);
glm::vec3 tangent = glm::cross(up, look);
glm::vec3 center = eye + camera_distance * look;
glm::mat3 orientation = glm::mat3(tangent, up, look);
bool fps_mode = false;

glm::vec4 light_position = glm::vec4(0.0f, 100.0f, 0.0f, 1.0f);
glm::mat4 view_matrix = glm::lookAt(eye, center, up);
glm::mat4 projection_matrix =
    glm::perspective((float)(kFov * (M_PI / 180.0f)), aspect, kNear, kFar);
glm::mat4 model_matrix = glm::mat4(1.0f);
glm::mat4 floor_model_matrix = glm::mat4(1.0f);

const char* vertex_shader =
    "#version 330 core\n"
    "uniform vec4 light_position;"
    "in vec4 vertex_position;"
    "out vec4 vs_light_direction;"
    "void main() {"
    "gl_Position = vertex_position;"
    "vs_light_direction = light_position - gl_Position;"
    "}";

const char* ogre_vertex_shader =
	"#version 330 core\n"
	"uniform vec4 light_position;"
	"in vec4 vertex_position;"
	"in vec3 vertex_normal;"
	"in vec4 undeformed_position;"
	"out vec4 vs_light_direction;"
	"out vec3 vs_vertex_normal;"
	"out vec4 udef_pos;"
	"void main() {"
	"gl_Position = vertex_position;"
	"udef_pos = undeformed_position;"
	"vs_light_direction = light_position - gl_Position;"
	"vs_vertex_normal = vertex_normal;"
	"}";

const char* geometry_shader =
    "#version 330 core\n"
    "layout (triangles) in;"
    "layout (triangle_strip, max_vertices = 3) out;"
    "uniform mat4 projection;"
    "uniform mat4 model;"
    "uniform mat4 view;"
    "uniform vec4 light_position;"
    "in vec4 vs_light_direction[];"
    "out vec4 face_normal;"
    "out vec4 light_direction;"
    "out vec4 world_position;"
    "void main() {"
    "int n = 0;"
    "vec3 a = gl_in[0].gl_Position.xyz;"
    "vec3 b = gl_in[1].gl_Position.xyz;"
    "vec3 c = gl_in[2].gl_Position.xyz;"
    "vec3 u = normalize(b - a);"
    "vec3 v = normalize(c - a);"
    "face_normal = normalize(vec4(normalize(cross(u, v)), 0.0));"
    "for (n = 0; n < gl_in.length(); n++) {"
    "light_direction = normalize(vs_light_direction[n]);"
    "world_position = gl_in[n].gl_Position;"
    "gl_Position = projection * view * model * gl_in[n].gl_Position;"
    "EmitVertex();"
    "}"
    "EndPrimitive();"
    "}";

const char* ogre_geometry_shader =
    "#version 330 core\n"
    "layout (triangles) in;"
    "layout (triangle_strip, max_vertices = 3) out;"
    "uniform mat4 projection;"
    "uniform mat4 model;"
    "uniform mat4 view;"
    "uniform vec4 light_position;"
    "in vec4 vs_light_direction[];"
	"in vec4 udef_pos[];"
	"in vec3 vs_vertex_normal[];"
    "out vec4 face_normal;"
    "out vec4 light_direction;"
    "out vec4 world_position;"
	"out vec4 udef_position;"
    "void main() {"
    "int n = 0;"
    "vec3 a = gl_in[0].gl_Position.xyz;"
    "vec3 b = gl_in[1].gl_Position.xyz;"
    "vec3 c = gl_in[2].gl_Position.xyz;"
    "vec3 u = normalize(b - a);"
    "vec3 v = normalize(c - a);"
  	"face_normal = normalize(vec4(normalize(cross(u, v)), 0));"
	"for (n = 0; n < gl_in.length(); n++) {"
    "light_direction = normalize(vs_light_direction[n]);"
	//"face_normal = normalize(vec4(vs_vertex_normal[n], 0));"
	"world_position = gl_in[n].gl_Position;"
    "gl_Position = projection * view * model * gl_in[n].gl_Position;"
    "udef_position = udef_pos[n];"
	"EmitVertex();"
    "}"  
    "EndPrimitive();"
    "}"; 


const char* line_geometry_shader =
	"#version 330\n"
	"layout (lines) in;"
	"layout (line_strip, max_vertices = 2) out;"
	"uniform mat4 projection;"
	"uniform mat4 model;"
	"uniform mat4 view;"
	"void main() {"
	"for (int n = 0; n < gl_in.length(); n++) {"
	"gl_Position = projection * view * model * gl_in[n].gl_Position;"
	"EmitVertex();"
	"}"
	"EndPrimitive();"
	"}";

const char* cylinder_geometry_shader =
    "#version 330\n"
    "layout (lines) in;"
    "layout (line_strip, max_vertices = 2) out;"
    "uniform mat4 projection;"
    "uniform mat4 model;"
    "uniform mat4 view;"
	"uniform vec4 origin;"
	"uniform vec4 normal;"
	"uniform vec4 binormal;"
	"out vec4 color;"
    "void main() {"
    "for (int n = 0; n < gl_in.length(); n++) {"
    "gl_Position = projection * view * model * gl_in[n].gl_Position;"
    "if (gl_in[0].gl_Position == origin && gl_in[1].gl_Position == normal) {"
	"color = vec4(1, 0, 0, 1);"
	"} else if (gl_in[0].gl_Position == origin && gl_in[1].gl_Position == binormal) {"
	"color = vec4(0, 0, 1, 1);"
	"} else {"
	"color = vec4(0, 1, 1, 1);"
	"}"
	"EmitVertex();"
    "}"  
    "EndPrimitive();"
    "}"; 

const char* floor_fragment_shader =
    "#version 330 core\n"
    "in vec4 face_normal;"
    "in vec4 light_direction;"
    "in vec4 world_position;"
    "out vec4 fragment_color;"
    "void main() {"
    "vec4 pos = world_position;"
    "float check_width = 0.25;"
    "float i = floor(pos.x / check_width);"
    "float j  = floor(pos.z / check_width);"
    "vec3 color = mod(i + j, 2) * vec3(1.0, 1.0, 1.0);"
    "float dot_nl = dot(normalize(light_direction), normalize(face_normal));"
    "dot_nl = clamp(dot_nl, 0.0, 1.0);"
    "color = clamp(dot_nl * color, 0.0, 1.0);"
    "fragment_color = vec4(color, 1.0);"
    "}";

const char* ogre_fragment_shader =
    "#version 330 core\n"
	"#define M_PI 3.1415926535\n"
    "in vec4 face_normal;"
    "in vec4 light_direction;"
	"in vec4 udef_position;"
	"uniform int enable_tex;"
	"uniform sampler2D tex;"
    "uniform vec3 c;"
	"uniform float ymin;"
	"uniform float ymax;"
	"out vec4 fragment_color;"
    "void main() {"
	"float u = atan(udef_position.z - c.z, udef_position.x - c.x) / (2 * M_PI);"
	"float v = (udef_position.y - ymin) / (ymax - ymin);"
	"float ndot = dot(normalize(light_direction), normalize(face_normal));"
	"ndot = clamp(ndot, 0, 1);"
	"if (enable_tex != 0) {"
	"fragment_color = clamp(ndot * texture(tex, vec2(u, v)), 0, 1);"
    "} else {"
	"fragment_color = clamp(ndot * vec4(0, 1, 0, 0.5), 0, 1);"
	"}"
	"}";

const char* skeleton_fragment_shader =
	"#version 330 core\n"
	"out vec4 fragment_color;"
	"void main() {"
	"fragment_color = vec4(1, 1, 0, 1);"
	"}";

const char* cylinder_fragment_shader =
	"#version 330 core\n"
	"out vec4 fragment_color;"
	"in vec4 color;"
	"void main() {"
	"fragment_color = color;"
	"}";

const char* OpenGlErrorToString(GLenum error) {
  switch (error) {
    case GL_NO_ERROR:
      return "GL_NO_ERROR";
      break;
    case GL_INVALID_ENUM:
      return "GL_INVALID_ENUM";
      break;
    case GL_INVALID_VALUE:
      return "GL_INVALID_VALUE";
      break;
    case GL_INVALID_OPERATION:
      return "GL_INVALID_OPERATION";
      break;
    case GL_OUT_OF_MEMORY:
      return "GL_OUT_OF_MEMORY";
      break;
    default:
      return "Unknown Error";
      break;
  }
  return "Unicorns Exist";
}

#define CHECK_SUCCESS(x) \
  if (!(x)) {            \
    glfwTerminate();     \
    exit(EXIT_FAILURE);  \
  }

#define CHECK_GL_SHADER_ERROR(id)                                           \
  {                                                                         \
    GLint status = 0;                                                       \
    GLint length = 0;                                                       \
    glGetShaderiv(id, GL_COMPILE_STATUS, &status);                          \
    glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);                         \
    if (!status) {                                                          \
      std::string log(length, 0);                                           \
      glGetShaderInfoLog(id, length, nullptr, &log[0]);                     \
      std::cerr << "Line :" << __LINE__ << " OpenGL Shader Error: Log = \n" \
                << &log[0];                                                 \
      glfwTerminate();                                                      \
      exit(EXIT_FAILURE);                                                   \
    }                                                                       \
  }

#define CHECK_GL_PROGRAM_ERROR(id)                                           \
  {                                                                          \
    GLint status = 0;                                                        \
    GLint length = 0;                                                        \
    glGetProgramiv(id, GL_LINK_STATUS, &status);                             \
    glGetProgramiv(id, GL_INFO_LOG_LENGTH, &length);                         \
    if (!status) {                                                           \
      std::string log(length, 0);                                            \
      glGetProgramInfoLog(id, length, nullptr, &log[0]);                     \
      std::cerr << "Line :" << __LINE__ << " OpenGL Program Error: Log = \n" \
                << &log[0];                                                  \
      glfwTerminate();                                                       \
      exit(EXIT_FAILURE);                                                    \
    }                                                                        \
  }

#define CHECK_GL_ERROR(statement)                                             \
  {                                                                           \
    { statement; }                                                            \
    GLenum error = GL_NO_ERROR;                                               \
    if ((error = glGetError()) != GL_NO_ERROR) {                              \
      std::cerr << "Line :" << __LINE__ << " OpenGL Error: code  = " << error \
                << " description =  " << OpenGlErrorToString(error);          \
      glfwTerminate();                                                        \
      exit(EXIT_FAILURE);                                                     \
    }                                                                         \
  }

template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {
  size_t count = std::min(v.size(), static_cast<size_t>(10));
  for (size_t i = 0; i < count; ++i) os << i << " " << v[i] << "\n";
  os << "size = " << v.size() << "\n";
  return os;
}

namespace glm {
std::ostream& operator<<(std::ostream& os, const glm::vec2& v) {
  os << glm::to_string(v);
  return os;
}

std::ostream& operator<<(std::ostream& os, const glm::vec3& v) {
  os << glm::to_string(v);
  return os;
}

std::ostream& operator<<(std::ostream& os, const glm::vec4& v) {
  os << glm::to_string(v);
  return os;
}

std::ostream& operator<<(std::ostream& os, const glm::mat4& v) {
  os << glm::to_string(v);
  return os;
}

std::ostream& operator<<(std::ostream& os, const glm::mat3& v) {
  os << glm::to_string(v);
  return os;
}
}  // namespace glm

void LoadObj(const std::string& file, std::vector<glm::vec4>& vertices,
             std::vector<glm::uvec3>& indices) {
	std::ifstream in(file);
	int i = 0, j = 0;
	glm::vec4 vertex = glm::vec4(0.0, 0.0, 0.0, 1.0);
	glm::uvec3 face_indices = glm::uvec3(0, 0, 0);

	while (in.good()) {
		char c = in.get();
		switch (c) {
			case 'v':
       			in >> vertex[0] >> vertex[1] >> vertex[2];
        		vertices.push_back(vertex);
        		break;
      		case 'f':
        		in >> face_indices[0] >> face_indices[1] >> face_indices[2];
        		face_indices -= 1;
        		indices.push_back(face_indices);
        		break;
      		default:
        		break;
    	}
  	}
  
	in.close();
}

void SaveJPEG(const std::string& filename, int image_width, int image_height,
              const unsigned char* pixels) {
  	struct jpeg_compress_struct cinfo;
  	struct jpeg_error_mgr jerr;
  	FILE* outfile;
  	JSAMPROW row_pointer[1];
  	int row_stride;

  	cinfo.err = jpeg_std_error(&jerr);
  	jpeg_create_compress(&cinfo);

  	CHECK_SUCCESS((outfile = fopen(filename.c_str(), "wb")) != NULL)
	
  	jpeg_stdio_dest(&cinfo, outfile);

  	cinfo.image_width = image_width;
  	cinfo.image_height = image_height;
  	cinfo.input_components = 3;
  	cinfo.in_color_space = JCS_RGB;
  	jpeg_set_defaults(&cinfo);
  	jpeg_set_quality(&cinfo, 100, true);
  	jpeg_start_compress(&cinfo, true);

  	row_stride = image_width * 3;

  	while (cinfo.next_scanline < cinfo.image_height) {
    	row_pointer[0] = const_cast<unsigned char*>(
        	&pixels[(cinfo.image_height - 1 - cinfo.next_scanline) * row_stride]);
    	jpeg_write_scanlines(&cinfo, row_pointer, 1);
  	}

  	jpeg_finish_compress(&cinfo);
  	fclose(outfile);

  	jpeg_destroy_compress(&cinfo);
}

bool LoadJPEG(const std::string& file_name, Image* image) {
  	FILE* file = fopen(file_name.c_str(), "rb");
  	struct jpeg_decompress_struct info;
  	struct jpeg_error_mgr err;

  	info.err = jpeg_std_error(&err);
  	jpeg_create_decompress(&info);

  	CHECK_SUCCESS(file != NULL);

  	jpeg_stdio_src(&info, file);
  	jpeg_read_header(&info, true);
  	jpeg_start_decompress(&info);
	
  	image->width = info.output_width;
  	image->height = info.output_height;

  	int channels = info.num_components;
  	long size = image->width * image->height * 3;

  	image->bytes = new unsigned char[size];
	
  	int a = (channels > 2 ? 1 : 0);
  	int b = (channels > 2 ? 2 : 0);
  	std::vector<unsigned char> scan_line(image->width * channels, 0);
  	unsigned char* p1 = &scan_line[0];
  	unsigned char** p2 = &p1;
  	unsigned char* out_scan_line = &image->bytes[0];
  	while (info.output_scanline < info.output_height) {
    	jpeg_read_scanlines(&info, p2, 1);
    	for (int i = 0; i < image->width; ++i) {
      		out_scan_line[3 * i] = scan_line[channels * i];
      		out_scan_line[3 * i + 1] = scan_line[channels * i + a];
      		out_scan_line[3 * i + 2] = scan_line[channels * i + b];
    	}
    	out_scan_line += image->width * 3;
  	}
  	
	jpeg_finish_decompress(&info);
  	fclose(file);
  	return true;
}

void ErrorCallback(int error, const char* description) {
  	std::cerr << "GLFW Error: " << description << "\n";
}

void KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
    	glfwSetWindowShouldClose(window, GL_TRUE);
  	else if (key == GLFW_KEY_W && action != GLFW_RELEASE) {
    	if (fps_mode)
      		eye -= zoom_speed * look;
    	else
     		camera_distance -= zoom_speed;
  	} else if (key == GLFW_KEY_S && action != GLFW_RELEASE) {
    	if (fps_mode)
      		eye += zoom_speed * look;
    	else
      		camera_distance += zoom_speed;
  	} else if (key == GLFW_KEY_A && action != GLFW_RELEASE) {
    	if (fps_mode)
      		eye -= pan_speed * tangent;
    	else
      		center -= pan_speed * tangent;
  	} else if (key == GLFW_KEY_D && action != GLFW_RELEASE) {
    	if (fps_mode)
      		eye += pan_speed * tangent;
    	else
      		center += pan_speed * tangent;
  	} else if (key == GLFW_KEY_LEFT && action != GLFW_RELEASE) {
/*
    	if (current_mouse_mode == kMouseModeCamera) {
      		glm::mat3 rotation = glm::mat3(glm::rotate(-roll_speed, look));
      		orientation = rotation * orientation;
      		tangent = glm::column(orientation, 0);
      		up = glm::column(orientation, 1);
      		look = glm::column(orientation, 2);
    	} else {
			if (bone_hit_idx != -1) {
                Bone* bone = skeleton.bones[bone_hit_idx];
                glm::vec3 t = glm::normalize(glm::vec3(
                        bone->bone2world(glm::vec4(1, 0, 0, 1))));
                bone->S = glm::rotate(bone->S, rotation_speed, glm::vec3(1, 0, 0));

                // Update the skeleton vertices and rebind vertices
                skeleton_vertices.clear();
                for (int i = 1; i < skeleton.bones.size(); i++) {
                    skeleton_vertices.push_back(skeleton.bones[i]->origin());
                    skeleton_vertices.push_back(skeleton.bones[i]->endpoint());
                }
    
                CHECK_GL_ERROR(glBindVertexArray(array_objects[kSkeletonVao]));
                CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
                                buffer_objects[kSkeletonVao][kVertexBuffer]));
                CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
                                sizeof(float) * skeleton_vertices.size() * 4, 
                                &skeleton_vertices[0], GL_STATIC_DRAW));
                CHECK_GL_ERROR(glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0)); 
                CHECK_GL_ERROR(glEnableVertexAttribArray(0));
            }  
		}
*/
  	} else if (key == GLFW_KEY_RIGHT && action != GLFW_RELEASE) {
/*
    	if (current_mouse_mode == kMouseModeCamera) {
      		glm::mat3 rotation = glm::mat3(glm::rotate(roll_speed, look));
      		orientation = rotation * orientation;
      		tangent = glm::column(orientation, 0);
      		up = glm::column(orientation, 1);
      		look = glm::column(orientation, 2);
    	} else {
			if (bone_hit_idx != -1) {
				Bone* bone = skeleton.bones[bone_hit_idx];
                bone->S = glm::rotate(bone->S, -rotation_speed, glm::vec3(1, 0, 0));

                // Update the skeleton vertices and rebind vertices
                skeleton_vertices.clear();
                for (int i = 1; i < skeleton.bones.size(); i++) {
                    skeleton_vertices.push_back(skeleton.bones[i]->origin());
                    skeleton_vertices.push_back(skeleton.bones[i]->endpoint());
                }

                CHECK_GL_ERROR(glBindVertexArray(array_objects[kSkeletonVao]));
                CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
                                buffer_objects[kSkeletonVao][kVertexBuffer]));
                CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
                                sizeof(float) * skeleton_vertices.size() * 4,
                                &skeleton_vertices[0], GL_STATIC_DRAW));
                CHECK_GL_ERROR(glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0));
                CHECK_GL_ERROR(glEnableVertexAttribArray(0));
			}
		}
*/
  	} else if (key == GLFW_KEY_DOWN && action != GLFW_RELEASE) {
    	if (fps_mode)
      		eye -= pan_speed * up;
    	else
      		center -= pan_speed * up;
  	} else if (key == GLFW_KEY_UP && action != GLFW_RELEASE) {
    	if (fps_mode)
      		eye += pan_speed * up;
    	else
      		center += pan_speed * up;
	} else if (key == GLFW_KEY_C && action != GLFW_RELEASE) {
    	fps_mode = !fps_mode;
  	} else if (key == GLFW_KEY_M && action != GLFW_RELEASE) {
    	current_mouse_mode = (current_mouse_mode + 1) % kNumMouseModes;
  	} else if (key == GLFW_KEY_J && action != GLFW_RELEASE) {
    	std::vector<unsigned char> pixels(3 * window_width * window_height, 0);
    	CHECK_GL_ERROR(glReadPixels(0, 0, window_width, window_height, 
					   GL_RGB, GL_UNSIGNED_BYTE, &pixels[0]));
    	std::string filename = "capture.jpg";
    	std::cout << "Encoding and saving to file '" + filename + "'\n";
    	SaveJPEG(filename, window_width, window_height, &pixels[0]);
  	} else if (key == GLFW_KEY_T && action != GLFW_RELEASE) {
		ogre_texture = (ogre_texture + 1) % 8;
	}
}

void MousePosCallback(GLFWwindow* window, double mouse_x, double mouse_y) {
/*
  	last_x = current_x;
  	last_y = current_y;
  	current_x = mouse_x;
  	current_y = window_height - mouse_y;
  	float delta_x = current_x - last_x;
  	float delta_y = current_y - last_y;
  	if (sqrt(delta_x * delta_x + delta_y * delta_y) < 1e-15) return;
  	glm::vec3 mouse_direction = glm::normalize(glm::vec3(delta_x, delta_y, 0.0f));
  	glm::vec2 mouse_start = glm::vec2(last_x, last_y);
  	glm::vec2 mouse_end = glm::vec2(current_x, current_y);
  	glm::uvec4 viewport = glm::uvec4(0, 0, window_width, window_height);
  	if (drag_state && current_button == GLFW_MOUSE_BUTTON_LEFT) {
    	if (current_mouse_mode == kMouseModeCamera) {
      		glm::vec3 axis = glm::normalize(
          	orientation * glm::vec3(mouse_direction.y, -mouse_direction.x, 0.0f));
      		orientation = glm::mat3(glm::rotate(rotation_speed, axis) * 
						  glm::mat4(orientation));
      		tangent = glm::column(orientation, 0);
      		up = glm::column(orientation, 1);
      		look = glm::column(orientation, 2);
    	} else {
			if (bone_hit_idx != -1) {
				Bone* bone = skeleton.bones[bone_hit_idx];
				glm::vec3 r = delta_x * glm::vec3(0, 1, 0) - delta_y * glm::vec3(0, 0, 1);
				bone->S = glm::rotate(bone->S, rotation_speed, r);

				// Update the skeleton vertices and rebind vertices
				skeleton_vertices.clear();
		        for (int i = 1; i < skeleton.bones.size(); i++) {
    		        skeleton_vertices.push_back(skeleton.bones[i]->origin());
    		        skeleton_vertices.push_back(skeleton.bones[i]->endpoint());
        		}
    
				CHECK_GL_ERROR(glBindVertexArray(array_objects[kSkeletonVao]));
        		CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
                                buffer_objects[kSkeletonVao][kVertexBuffer]));
        		CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
                                sizeof(float) * skeleton_vertices.size() * 4,
                                &skeleton_vertices[0], GL_STATIC_DRAW));
        		CHECK_GL_ERROR(glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0));
        		CHECK_GL_ERROR(glEnableVertexAttribArray(0));
			}		
	
	  	}
  	} else {
  		float near_height = 2.0 * kNear * tan((M_PI / 180.0f) * (kFov / 2.0));
		float near_width  = aspect * near_height;
		float mx_norm = (mouse_x / window_width - 0.5f) * near_width;
		float my_norm = (mouse_y / window_height - 0.5f) * near_height;
		glm::vec3 mouse_ray = glm::normalize(
				(mx_norm * tangent) - (my_norm * up) - (kNear * look));	
		
		bone_hit_idx = -1;
		float min_dist = std::numeric_limits<float>::max();
		for (int i = 1; i < skeleton.bones.size(); i++) {
			Bone* bone = skeleton.bones[i];
			glm::vec2 in = skeleton_indices[i-1];
			glm::vec3 e1 = glm::vec3(skeleton_vertices[in.x]);
			glm::vec3 e2 = glm::vec3(skeleton_vertices[in.y]);
			
			glm::vec3 tangent = glm::normalize(e2 - e1);
			glm::vec3 u = mouse_ray;
			glm::vec3 v = tangent;
			glm::vec3 w = eye - e1;

			float a = glm::dot(u, u);
			float b = glm::dot(u, v);
			float c = glm::dot(v, v);
			float d = glm::dot(u, w);
			float e = glm::dot(v, w);
			
			float m1 = b * e - c * d;
			float m2 = a * e - b * d;
			float m3 = a * c - b * b;

			glm::vec3 dist = (w + ((m1 * u) - (m2 * v)) / m3);
			float short_dist_ray = glm::length(dist);
			float s_c = m1 / m3;
			float t_c = m2 / m3;

			if (short_dist_ray <= kCylinderRadius && s_c >= 0 &&
				t_c >= 0 && t_c <= bone->length && short_dist_ray < min_dist) {
				bone_hit_idx = i;
				min_dist = short_dist_ray;
			}				
		}
	}
*/
}

void MouseButtonCallback(GLFWwindow* window, int button, int action, int mods) {
  drag_state = (action == GLFW_PRESS);
  current_button = button;
}

int main(int argc, char* argv[]) {
	if (!glfwInit()) exit(EXIT_FAILURE);
	glfwSetErrorCallback(ErrorCallback);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_SAMPLES, 4);
	GLFWwindow* window = glfwCreateWindow(window_width, window_height,
                                          &window_title[0], nullptr, nullptr);
  	CHECK_SUCCESS(window != nullptr);

  	glfwMakeContextCurrent(window);
  	glewExperimental = GL_TRUE;
  	CHECK_SUCCESS(glewInit() == GLEW_OK);
  	glGetError();  // clear GLEW's error for it

  	glfwSetKeyCallback(window, KeyCallback);
  	glfwSetCursorPosCallback(window, MousePosCallback);
  	glfwSetMouseButtonCallback(window, MouseButtonCallback);
  	glfwSwapInterval(1);
  	const GLubyte* renderer = glGetString(GL_RENDERER);  // get renderer string
  	const GLubyte* version = glGetString(GL_VERSION);    // version as a string
  	std::cout << "Renderer: " << renderer << "\n";
  	std::cout << "OpenGL version supported:" << version << "\n";

	/**************
	 * Load Floor *
	 **************/
  	std::vector<glm::vec4> floor_vertices;
  	std::vector<glm::uvec3> floor_faces;
  	floor_vertices.push_back(glm::vec4(kFloorXMin, kFloorY, kFloorZMax, 1.0f));
  	floor_vertices.push_back(glm::vec4(kFloorXMax, kFloorY, kFloorZMax, 1.0f));
  	floor_vertices.push_back(glm::vec4(kFloorXMax, kFloorY, kFloorZMin, 1.0f));
  	floor_vertices.push_back(glm::vec4(kFloorXMin, kFloorY, kFloorZMin, 1.0f));
  	floor_faces.push_back(glm::uvec3(0, 1, 2));
  	floor_faces.push_back(glm::uvec3(2, 3, 0));

	/*****************
	 * Load Skeleton *
	 *****************/
/*
	for (int i = 0; i < skeleton.bones.size(); i++) {
		if (skeleton.bones[i]->id >= 0) {
			int size = skeleton_vertices.size();
			skeleton_indices.push_back(glm::uvec2(size, size+1));
			skeleton_vertices.push_back(skeleton.bones[i]->origin());
			skeleton_vertices.push_back(skeleton.bones[i]->endpoint());
		}
	}
*/

	/*************
	 * Load Ogre *
	 *************/
//	std::vector<glm::vec4> ogre_vertices;
//	std::vector<glm::uvec3> ogre_faces;
//	LoadObj("ogre-rigged/ogre.obj", ogre_vertices, ogre_faces);

	/****************************
	 * Average Ogre Coordinates *
	 ****************************/
/*
	glm::vec3 c = glm::vec3(0, 0, 0);
	float ymin = std::numeric_limits<float>::max();
	float ymax = std::numeric_limits<float>::min();
	for(int i = 0; i < ogre_vertices.size(); i++){
		c += glm::vec3(ogre_vertices[i]);
		if(ogre_vertices[i].y > ymax)
			ymax = ogre_vertices[i].y;
		if(ogre_vertices[i].y < ymin)
			ymin = ogre_vertices[i].y;
	}
	c /= ogre_vertices.size();
*/

	/*****************
	 * Load Cylinder *
	 *****************/
/*
	std::vector<glm::vec4> cylinder_vertices;
	std::vector<glm::uvec2> cylinder_indices;
	for (double i = 0; i < 2 * M_PI; i += 0.5) {
		double x = glm::cos(i) * kCylinderRadius;
		double y = glm::sin(i) * kCylinderRadius;

		// Create cylinder lines
		int size = cylinder_vertices.size();
		cylinder_indices.push_back(glm::uvec2(size+0, size+1));
		cylinder_indices.push_back(glm::uvec2(size+1, size+2));
		if (size > 0) {
			cylinder_indices.push_back(glm::uvec2(size+0, size-3));
			cylinder_indices.push_back(glm::uvec2(size+1, size-2));
			cylinder_indices.push_back(glm::uvec2(size+2, size-1));
		}

		// Create cylinder vertices
		cylinder_vertices.push_back(glm::vec4(0.0, y, x, 1));
		cylinder_vertices.push_back(glm::vec4(0.5, y, x, 1));
		cylinder_vertices.push_back(glm::vec4(1.0, y, x, 1));
	}

	cylinder_indices.push_back(glm::uvec2(cylinder_vertices.size()-1, 2));
	cylinder_indices.push_back(glm::uvec2(cylinder_vertices.size()-2, 1));
	cylinder_indices.push_back(glm::uvec2(cylinder_vertices.size()-3, 0));
*/

	/************
	 * Load JPG *
	 ************/
/*
  	std::vector<std::string> jpeg_file_names;
  	DIR* dir;
  	struct dirent* entry;
  	CHECK_SUCCESS((dir = opendir("./textures")) != NULL);
  	while ((entry = readdir(dir)) != NULL) {
    	std::string file_name(entry->d_name);
    	std::transform(file_name.begin(), file_name.end(), file_name.begin(), tolower);
    	if (file_name.find(".jpg") != std::string::npos)
      		jpeg_file_names.push_back(file_name);
  	}
  	closedir(dir);

  	std::vector<Image> images(jpeg_file_names.size());
  	for (int i = 0; i < jpeg_file_names.size(); ++i) {
    	std::string file_name = "./textures/" + jpeg_file_names[i];
    	LoadJPEG(file_name, &images[i]);
    	std::cout << "Loaded '" << file_name << "' width = " << images[i].width
        	      << " height = " << images[i].height << "\n";
  	}
*/
	/************
	 * Textures *
	 ************/
	//std::cout << "IAMGES SIZE = " << images.size() << "\n";
/*
	GLuint textures[images.size()];
	GLuint samplers[images.size()];
	CHECK_GL_ERROR(glGenTextures(images.size(), textures));
	CHECK_GL_ERROR(glGenSamplers(images.size(), samplers));
	for (int i = 0; i < images.size(); i++) {
		CHECK_GL_ERROR(glBindTexture(GL_TEXTURE_2D, textures[i]));
		CHECK_GL_ERROR(glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGB8, 
				images[i].width, images[i].height));
		CHECK_GL_ERROR(glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 
				images[i].width, images[i].height, GL_RGB,
				GL_UNSIGNED_BYTE, (const GLvoid*) images[i].bytes));
		
		CHECK_GL_ERROR(glSamplerParameteri(samplers[i], GL_TEXTURE_MAG_FILTER, GL_LINEAR));
		CHECK_GL_ERROR(glSamplerParameteri(samplers[i], GL_TEXTURE_MIN_FILTER, GL_LINEAR));
	}
*/
	
	/*****************
	 * Setup VAO/VBO *
	 *****************/
	CHECK_GL_ERROR(glGenVertexArrays(kNumVaos, array_objects));

	// Switch to Floor VAO and setup buffer objects
  	CHECK_GL_ERROR(glBindVertexArray(array_objects[kFloorVao]));
  	CHECK_GL_ERROR(glGenBuffers(kNumVbos, &buffer_objects[kFloorVao][0]));

  	CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER, 
				   				buffer_objects[kFloorVao][kVertexBuffer]));
  	CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
                              	sizeof(float) * floor_vertices.size() * 4,
                              	&floor_vertices[0], GL_STATIC_DRAW));
  	CHECK_GL_ERROR(glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0));
  	CHECK_GL_ERROR(glEnableVertexAttribArray(0));

  	CHECK_GL_ERROR(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
								buffer_objects[kFloorVao][kIndexBuffer]));
  	CHECK_GL_ERROR(glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                              	sizeof(uint32_t) * floor_faces.size() * 3,
                              	&floor_faces[0], GL_STATIC_DRAW));

	// Switch to Ogre VAO and setup buffer objects
    CHECK_GL_ERROR(glBindVertexArray(array_objects[kOgreVao]));
    CHECK_GL_ERROR(glGenBuffers(kNumVbos, &buffer_objects[kOgreVao][0]));

    CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
                                buffer_objects[kOgreVao][kVertexBuffer]));
    CHECK_GL_ERROR(glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0));
    CHECK_GL_ERROR(glEnableVertexAttribArray(0));

	CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
								buffer_objects[kOgreVao][kUndeformedBuffer]));
	CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
								sizeof(float) * ogre_vertices.size() * 4,
								&ogre_vertices[0], GL_STATIC_DRAW));
	CHECK_GL_ERROR(glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0));
	CHECK_GL_ERROR(glEnableVertexAttribArray(1));

	CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
								buffer_objects[kOgreVao][kVertexNormalBuffer]));
	CHECK_GL_ERROR(glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, 0, 0));
	CHECK_GL_ERROR(glEnableVertexAttribArray(2));

    CHECK_GL_ERROR(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
                                buffer_objects[kOgreVao][kIndexBuffer]));
    CHECK_GL_ERROR(glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                                sizeof(uint32_t) * ogre_faces.size() * 3,
                                &ogre_faces[0], GL_STATIC_DRAW));

  	// Switch to Skeleton VAO and setup buffer objects
	CHECK_GL_ERROR(glBindVertexArray(array_objects[kSkeletonVao]));
	CHECK_GL_ERROR(glGenBuffers(kNumVbos, &buffer_objects[kSkeletonVao][0]));

	CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
								buffer_objects[kSkeletonVao][kVertexBuffer]));
	CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
								sizeof(float) * skeleton_vertices.size() * 4,
								&skeleton_vertices[0], GL_STATIC_DRAW));
	CHECK_GL_ERROR(glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0));
	CHECK_GL_ERROR(glEnableVertexAttribArray(0));

	CHECK_GL_ERROR(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
								buffer_objects[kSkeletonVao][kIndexBuffer]));
	CHECK_GL_ERROR(glBufferData(GL_ELEMENT_ARRAY_BUFFER,
								sizeof(uint32_t) * skeleton_indices.size() * 2,
								&skeleton_indices[0], GL_STATIC_DRAW));
	
    // Switch to Cylinder VAO and setup buffer objects
    CHECK_GL_ERROR(glBindVertexArray(array_objects[kCylinderVao]));
    CHECK_GL_ERROR(glGenBuffers(kNumVbos, &buffer_objects[kCylinderVao][0]));

    CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
                                buffer_objects[kCylinderVao][kVertexBuffer]));
    CHECK_GL_ERROR(glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0));
    CHECK_GL_ERROR(glEnableVertexAttribArray(0));

    CHECK_GL_ERROR(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
                                buffer_objects[kCylinderVao][kIndexBuffer]));
    CHECK_GL_ERROR(glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                                sizeof(uint32_t) * cylinder_indices.size() * 2,
                                &cylinder_indices[0], GL_STATIC_DRAW));

	/*****************
	 * Vertex Shader *
	 *****************/
  	GLuint vertex_shader_id = 0;
  	const char* vertex_source_pointer = vertex_shader;
  	CHECK_GL_ERROR(vertex_shader_id = glCreateShader(GL_VERTEX_SHADER));
  	CHECK_GL_ERROR(glShaderSource(vertex_shader_id, 1, &vertex_source_pointer, nullptr));
  	glCompileShader(vertex_shader_id);
  	CHECK_GL_SHADER_ERROR(vertex_shader_id);

	/**********************
	 * Ogre Vertex Shader *
	 **********************/
	GLuint ogre_vertex_shader_id = 0;
	const char* ogre_vertex_source_pointer = ogre_vertex_shader;
	CHECK_GL_ERROR(ogre_vertex_shader_id = glCreateShader(GL_VERTEX_SHADER));
	CHECK_GL_ERROR(glShaderSource(ogre_vertex_shader_id, 1, 
			&ogre_vertex_source_pointer, nullptr));
	glCompileShader(ogre_vertex_shader_id);
	CHECK_GL_SHADER_ERROR(ogre_vertex_shader_id);

	/*******************
	 * Geometry Shader *
	 *******************/
  	GLuint geometry_shader_id = 0;
  	const char* geometry_source_pointer = geometry_shader;
  	CHECK_GL_ERROR(geometry_shader_id = glCreateShader(GL_GEOMETRY_SHADER));
  	CHECK_GL_ERROR(glShaderSource(geometry_shader_id, 1, &geometry_source_pointer, nullptr));
  	glCompileShader(geometry_shader_id);
  	CHECK_GL_SHADER_ERROR(geometry_shader_id);

	/************************
	 * Ogre Geometry Shader *
	 ************************/
	GLuint ogre_geometry_shader_id = 0;
    const char* ogre_geometry_source_pointer = ogre_geometry_shader;
    CHECK_GL_ERROR(ogre_geometry_shader_id = glCreateShader(GL_GEOMETRY_SHADER));
    CHECK_GL_ERROR(glShaderSource(ogre_geometry_shader_id, 1, 
			&ogre_geometry_source_pointer, nullptr));
    glCompileShader(ogre_geometry_shader_id);
    CHECK_GL_SHADER_ERROR(ogre_geometry_shader_id);

	/****************************
	 * Cylinder Geometry Shader *
	 ****************************/
	GLuint cylinder_geometry_shader_id = 0;
    const char* cylinder_geometry_source_pointer = cylinder_geometry_shader;
    CHECK_GL_ERROR(cylinder_geometry_shader_id = glCreateShader(GL_GEOMETRY_SHADER));
    CHECK_GL_ERROR(glShaderSource(cylinder_geometry_shader_id, 1, 
            &cylinder_geometry_source_pointer, nullptr));
    glCompileShader(cylinder_geometry_shader_id);
    CHECK_GL_SHADER_ERROR(cylinder_geometry_shader_id);

	/************************
	 * Line Geometry Shader *
	 ************************/
	GLuint line_geometry_shader_id = 0;
	const char* line_geometry_source_pointer = line_geometry_shader;
	CHECK_GL_ERROR(line_geometry_shader_id = glCreateShader(GL_GEOMETRY_SHADER));
	CHECK_GL_ERROR(glShaderSource(line_geometry_shader_id, 1, 
				   &line_geometry_source_pointer, nullptr));
	glCompileShader(line_geometry_shader_id);
	CHECK_GL_SHADER_ERROR(line_geometry_shader_id);	

	/*************************
	 * Floor Fragment Shader *
	 *************************/
  	GLuint floor_fragment_shader_id = 0;
  	const char* floor_fragment_source_pointer = floor_fragment_shader;
  	CHECK_GL_ERROR(floor_fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER));
  	CHECK_GL_ERROR(glShaderSource(floor_fragment_shader_id, 1,
                                  &floor_fragment_source_pointer, nullptr));
  	glCompileShader(floor_fragment_shader_id);
  	CHECK_GL_SHADER_ERROR(floor_fragment_shader_id);

	/************************
	 * Ogre Fragment Shader *
	 ************************/
	GLuint ogre_fragment_shader_id = 0;
    const char* ogre_fragment_source_pointer = ogre_fragment_shader;
    CHECK_GL_ERROR(ogre_fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER));
    CHECK_GL_ERROR(glShaderSource(ogre_fragment_shader_id, 1,
                                  &ogre_fragment_source_pointer, nullptr));
    glCompileShader(ogre_fragment_shader_id);
    CHECK_GL_SHADER_ERROR(ogre_fragment_shader_id);

	/****************************
	 * Skeleton Fragment Shader *
	 ****************************/
	GLuint skeleton_fragment_shader_id = 0;
	const char* skeleton_fragment_source_pointer = skeleton_fragment_shader;
	CHECK_GL_ERROR(skeleton_fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER));
	CHECK_GL_ERROR(glShaderSource(skeleton_fragment_shader_id, 1,
								  &skeleton_fragment_source_pointer, nullptr));
	glCompileShader(skeleton_fragment_shader_id);
	CHECK_GL_SHADER_ERROR(skeleton_fragment_shader_id);

	/****************************
	 * Cylinder Fragment Shader *
	 ****************************/
	GLuint cylinder_fragment_shader_id = 0;
	const char* cylinder_fragment_source_pointer = cylinder_fragment_shader;
	CHECK_GL_ERROR(cylinder_fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER));
	CHECK_GL_ERROR(glShaderSource(cylinder_fragment_shader_id, 1,
								  &cylinder_fragment_source_pointer, nullptr));
	glCompileShader(cylinder_fragment_shader_id);
	CHECK_GL_SHADER_ERROR(cylinder_fragment_shader_id);

	/*****************
	 * Floor Program *
	 *****************/
	// Attach shaders and link program
	GLuint floor_program_id = 0;
  	CHECK_GL_ERROR(floor_program_id = glCreateProgram());
  	CHECK_GL_ERROR(glAttachShader(floor_program_id, vertex_shader_id));
  	CHECK_GL_ERROR(glAttachShader(floor_program_id, floor_fragment_shader_id));
  	CHECK_GL_ERROR(glAttachShader(floor_program_id, geometry_shader_id));
	CHECK_GL_ERROR(glBindAttribLocation(floor_program_id, 0, "vertex_position"));
  	CHECK_GL_ERROR(glBindFragDataLocation(floor_program_id, 0, "fragment_color"));
  	glLinkProgram(floor_program_id);
  	CHECK_GL_PROGRAM_ERROR(floor_program_id);

  	// Get the uniform locations
  	GLint floor_projection_matrix_location = 0;
  	CHECK_GL_ERROR(floor_projection_matrix_location =
                   glGetUniformLocation(floor_program_id, "projection"));
  	GLint floor_model_matrix_location = 0;
  	CHECK_GL_ERROR(floor_model_matrix_location =
                   glGetUniformLocation(floor_program_id, "model"));
  	GLint floor_view_matrix_location = 0;
  	CHECK_GL_ERROR(floor_view_matrix_location =
                   glGetUniformLocation(floor_program_id, "view"));
  	GLint floor_light_position_location = 0;
  	CHECK_GL_ERROR(floor_light_position_location =
                   glGetUniformLocation(floor_program_id, "light_position"));

	/********************
	 * Skeleton Program *
	 ********************/
	// Attach shaders and link program	
	GLuint skeleton_program_id = 0;
	CHECK_GL_ERROR(skeleton_program_id = glCreateProgram());
	CHECK_GL_ERROR(glAttachShader(skeleton_program_id, vertex_shader_id));
	CHECK_GL_ERROR(glAttachShader(skeleton_program_id, line_geometry_shader_id));
	CHECK_GL_ERROR(glAttachShader(skeleton_program_id, skeleton_fragment_shader_id));
	CHECK_GL_ERROR(glBindAttribLocation(skeleton_program_id, 0, "vertex_position"));
	CHECK_GL_ERROR(glBindFragDataLocation(skeleton_program_id, 0, "fragment_color"));
	glLinkProgram(skeleton_program_id);
	CHECK_GL_PROGRAM_ERROR(skeleton_program_id);

	// Get uniform locations
	GLint skeleton_projection_matrix_location = 0;
	CHECK_GL_ERROR(skeleton_projection_matrix_location = 
				   glGetUniformLocation(skeleton_program_id, "projection"));
	GLint skeleton_model_matrix_location = 0;
	CHECK_GL_ERROR(skeleton_model_matrix_location = 
				   glGetUniformLocation(skeleton_program_id, "model"));
	GLint skeleton_view_matrix_location = 0;
	CHECK_GL_ERROR(skeleton_view_matrix_location =
				   glGetUniformLocation(skeleton_program_id, "view"));
	GLint skeleton_light_position_location = 0;
	CHECK_GL_ERROR(skeleton_light_position_location =
				   glGetUniformLocation(skeleton_program_id, "light_position"));

    /********************
     * Cylinder Program *
     ********************/
    // Attach shaders and link program  
    GLuint cylinder_program_id = 0;
    CHECK_GL_ERROR(cylinder_program_id = glCreateProgram());
    CHECK_GL_ERROR(glAttachShader(cylinder_program_id, vertex_shader_id));
    CHECK_GL_ERROR(glAttachShader(cylinder_program_id, cylinder_geometry_shader_id));
    CHECK_GL_ERROR(glAttachShader(cylinder_program_id, cylinder_fragment_shader_id));
    CHECK_GL_ERROR(glBindAttribLocation(cylinder_program_id, 0, "vertex_position"));
	CHECK_GL_ERROR(glBindFragDataLocation(cylinder_program_id, 0, "fragment_color"));
    glLinkProgram(cylinder_program_id);
    CHECK_GL_PROGRAM_ERROR(cylinder_program_id);

    // Get uniform locations
    GLint cylinder_projection_matrix_location = 0;
    CHECK_GL_ERROR(cylinder_projection_matrix_location = 
                   glGetUniformLocation(cylinder_program_id, "projection"));
    GLint cylinder_model_matrix_location = 0;
    CHECK_GL_ERROR(cylinder_model_matrix_location = 
                   glGetUniformLocation(cylinder_program_id, "model"));
    GLint cylinder_view_matrix_location = 0;
    CHECK_GL_ERROR(cylinder_view_matrix_location =
                   glGetUniformLocation(cylinder_program_id, "view"));
    GLint cylinder_light_position_location = 0;
    CHECK_GL_ERROR(cylinder_light_position_location =
                   glGetUniformLocation(cylinder_program_id, "light_position"));
  	GLint cylinder_origin_location = 0;
	CHECK_GL_ERROR(cylinder_origin_location =
				   glGetUniformLocation(cylinder_program_id, "origin"));
	GLint cylinder_normal_location = 0;
	CHECK_GL_ERROR(cylinder_normal_location =
				   glGetUniformLocation(cylinder_program_id, "normal"));
	GLint cylinder_binormal_location = 0;
	CHECK_GL_ERROR(cylinder_binormal_location =
				   glGetUniformLocation(cylinder_program_id, "binormal"));

	/****************
     * Ogre Program *
     ****************/
    // Attach shaders and link program  
    GLuint ogre_program_id = 0;
    CHECK_GL_ERROR(ogre_program_id = glCreateProgram());
    CHECK_GL_ERROR(glAttachShader(ogre_program_id, ogre_vertex_shader_id));
    CHECK_GL_ERROR(glAttachShader(ogre_program_id, ogre_geometry_shader_id));
    CHECK_GL_ERROR(glAttachShader(ogre_program_id, ogre_fragment_shader_id));
    CHECK_GL_ERROR(glBindAttribLocation(ogre_program_id, 0, "vertex_position"));
    CHECK_GL_ERROR(glBindAttribLocation(ogre_program_id, 0, "undeformed_position"));
	CHECK_GL_ERROR(glBindAttribLocation(ogre_program_id, 0, "vertex_normal"));
	CHECK_GL_ERROR(glBindFragDataLocation(ogre_program_id, 0, "fragment_color"));
    glLinkProgram(ogre_program_id);
    CHECK_GL_PROGRAM_ERROR(ogre_program_id);

    // Get uniform locations
    GLint ogre_projection_matrix_location = 0;
    CHECK_GL_ERROR(ogre_projection_matrix_location =
                   glGetUniformLocation(ogre_program_id, "projection"));
    GLint ogre_model_matrix_location = 0;
    CHECK_GL_ERROR(ogre_model_matrix_location =
                   glGetUniformLocation(ogre_program_id, "model"));
    GLint ogre_view_matrix_location = 0;
    CHECK_GL_ERROR(ogre_view_matrix_location =
                   glGetUniformLocation(ogre_program_id, "view"));
    GLint ogre_light_position_location = 0;
    CHECK_GL_ERROR(ogre_light_position_location =
                   glGetUniformLocation(ogre_program_id, "light_position"));
	GLint ogre_c_location = 0;
	CHECK_GL_ERROR(ogre_c_location =
				   glGetUniformLocation(ogre_program_id, "c"));
	GLint ogre_ymin_location = 0;
	CHECK_GL_ERROR(ogre_ymin_location = 
				   glGetUniformLocation(ogre_program_id, "ymin"));
	GLint ogre_ymax_location = 0;
	CHECK_GL_ERROR(ogre_ymax_location = 
				   glGetUniformLocation(ogre_program_id, "ymax"));
	GLint ogre_sampler_location = 0;
	CHECK_GL_ERROR(ogre_sampler_location =
				   glGetUniformLocation(ogre_program_id, "tex"));
	GLint ogre_enable_tex_location = 0;
	CHECK_GL_ERROR(ogre_enable_tex_location =
				   glGetUniformLocation(ogre_program_id, "enable_tex"));

	std::vector<glm::vec4> ogre_vertices_tform;
	std::vector<glm::vec4> cylinder_vertices_tform;
	std::vector<glm::uvec2> cylinder_indices_tform;
	std::vector<glm::vec3> ogre_vertex_normals;
	std::vector<float> ogre_vertex_counts;

	while (!glfwWindowShouldClose(window)) {
    	// Setup window for rendering
		glfwGetFramebufferSize(window, &window_width, &window_height);
    	glViewport(0, 0, window_width, window_height);
    	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
    	glEnable(GL_DEPTH_TEST);
    	glEnable(GL_MULTISAMPLE);
    	glEnable(GL_BLEND);
    	glEnable(GL_CULL_FACE);
    	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    	glDepthFunc(GL_LESS);
    	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    	glCullFace(GL_BACK);

    	// Compute view and projection matrices
		if (fps_mode)
      		center = eye - camera_distance * look;
    	else
      		eye = center + camera_distance * look;

    	view_matrix = glm::lookAt(eye, center, up);
    	light_position = glm::vec4(eye, 1.0f);
    	aspect = static_cast<float>(window_width) / window_height;
    	projection_matrix = glm::perspective((float) (kFov * (M_PI / 180.0f)), 
											 aspect, kNear, kFar);
    	model_matrix = glm::mat4(1.0f);

		/****************
		 * Render Floor *
		 ****************/
    	CHECK_GL_ERROR(glBindVertexArray(array_objects[kFloorVao]));
    	CHECK_GL_ERROR(glUseProgram(floor_program_id));
    	CHECK_GL_ERROR(glUniformMatrix4fv(floor_projection_matrix_location, 1,
                                      	  GL_FALSE, &projection_matrix[0][0]));
    	CHECK_GL_ERROR(glUniformMatrix4fv(floor_model_matrix_location, 1, GL_FALSE,
                                      	  &model_matrix[0][0]));
    	CHECK_GL_ERROR(glUniformMatrix4fv(floor_view_matrix_location, 1, GL_FALSE,
                                      	  &view_matrix[0][0]));
    	CHECK_GL_ERROR(glUniform4fv(floor_light_position_location, 1, &light_position[0]));
		CHECK_GL_ERROR(glDrawElements(GL_TRIANGLES, floor_faces.size() * 3,
                                  	  GL_UNSIGNED_INT, 0));

		/*******************
	 	 * Render Skeleton *
	 	 *******************/
 		CHECK_GL_ERROR(glBindVertexArray(array_objects[kSkeletonVao]));
		CHECK_GL_ERROR(glUseProgram(skeleton_program_id));
		CHECK_GL_ERROR(glUniformMatrix4fv(skeleton_projection_matrix_location, 1,
										  GL_FALSE, &projection_matrix[0][0]));
		CHECK_GL_ERROR(glUniformMatrix4fv(skeleton_model_matrix_location, 1,
										  GL_FALSE, &model_matrix[0][0]));
		CHECK_GL_ERROR(glUniformMatrix4fv(skeleton_view_matrix_location, 1,
										  GL_FALSE, &view_matrix[0][0]));
		CHECK_GL_ERROR(glUniform4fv(skeleton_light_position_location, 1, &light_position[0]));
		CHECK_GL_ERROR(glDrawElements(GL_LINES, skeleton_indices.size() * 2,
									  GL_UNSIGNED_INT, 0));

		/*******************
		 * Render Cylinder *
		 *******************/
/*
		if (bone_hit_idx != -1) {
			Bone* bone = skeleton.bones[bone_hit_idx];
			cylinder_vertices_tform.clear();
			cylinder_indices_tform.clear();
			cylinder_indices_tform = std::vector<glm::uvec2>(cylinder_indices);		
			for (auto v : cylinder_vertices) {
				glm::vec4 s = glm::vec4(v.x * bone->length, v.y, v.z, v.w);
				cylinder_vertices_tform.push_back(bone->bone2world(s));
			}

			// Add the normal and binormal vectors
			int cyl_size = cylinder_vertices_tform.size();
			cylinder_indices_tform.push_back(glm::uvec2(cyl_size, cyl_size+1));
			cylinder_indices_tform.push_back(glm::uvec2(cyl_size, cyl_size+2));		

			glm::vec4 o = bone->origin();
			glm::vec4 n = bone->bone2world(glm::vec4(0, 2*kCylinderRadius, 0, 1));
			glm::vec4 b = bone->bone2world(glm::vec4(0, 0, 2*kCylinderRadius, 1));			
			cylinder_vertices_tform.push_back(o);
			cylinder_vertices_tform.push_back(n);
			cylinder_vertices_tform.push_back(b);

			// Bind the transformed cylinder to the VAO
			CHECK_GL_ERROR(glBindVertexArray(array_objects[kCylinderVao]));
			CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
								buffer_objects[kCylinderVao][kVertexBuffer]));
			CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
								sizeof(float) * cylinder_vertices_tform.size() * 4,
								&cylinder_vertices_tform[0], GL_STATIC_DRAW));
			CHECK_GL_ERROR(glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0));
			CHECK_GL_ERROR(glEnableVertexAttribArray(0));

    		CHECK_GL_ERROR(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
                                buffer_objects[kCylinderVao][kIndexBuffer]));
    		CHECK_GL_ERROR(glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                                sizeof(uint32_t) * cylinder_indices_tform.size() * 2,
                                &cylinder_indices_tform[0], GL_STATIC_DRAW));

			CHECK_GL_ERROR(glUseProgram(cylinder_program_id));
        	CHECK_GL_ERROR(glUniformMatrix4fv(cylinder_projection_matrix_location, 1,
        	                                  GL_FALSE, &projection_matrix[0][0]));
        	CHECK_GL_ERROR(glUniformMatrix4fv(cylinder_model_matrix_location, 1,
        	                                  GL_FALSE, &model_matrix[0][0]));
        	CHECK_GL_ERROR(glUniformMatrix4fv(cylinder_view_matrix_location, 1,
        	                                  GL_FALSE, &view_matrix[0][0]));
        	CHECK_GL_ERROR(glUniform4fv(cylinder_light_position_location, 
										1, &light_position[0]));
			CHECK_GL_ERROR(glUniform4fv(cylinder_origin_location, 1, &o[0]));
			CHECK_GL_ERROR(glUniform4fv(cylinder_normal_location, 1, &n[0]));
			CHECK_GL_ERROR(glUniform4fv(cylinder_binormal_location, 1, &b[0]));
        	CHECK_GL_ERROR(glDrawElements(GL_LINES, cylinder_indices_tform.size() * 2,
        	                              GL_UNSIGNED_INT, 0));
		}
	*/

		/***************
         * Render Ogre *
         ***************/
/*
		ogre_vertices_tform.clear();
		std::vector<glm::mat4> u, d;
		for (int i = 0; i < skeleton.bones.size(); i++) {
			u.push_back(glm::inverse(skeleton.bones[i]->undeformed()));
			d.push_back(skeleton.bones[i]->deformed());
		}

		for (int j = 0; j < ogre_vertices.size(); j++) {
			glm::vec4 pos = glm::vec4(0, 0, 0, 0);
			for (int i = 1; i < skeleton.bones.size(); i++) {
				Bone* bone = skeleton.bones[i];
				pos += (float) bone->weights[j] * d[i] * u[i] * ogre_vertices[j];
			}
			ogre_vertices_tform.push_back(pos);
		}

		ogre_vertex_normals.clear();
		ogre_vertex_counts.clear();
		for (int i = 0; i < ogre_vertices.size(); i++) {
			ogre_vertex_normals.push_back(glm::vec3(0, 0, 0));
			ogre_vertex_counts.push_back(0);
		}

		for (int i = 0; i < ogre_faces.size(); i++) {
			glm::vec3 p1 = glm::vec3(ogre_vertices_tform[ogre_faces[i].x]);
			glm::vec3 p2 = glm::vec3(ogre_vertices_tform[ogre_faces[i].y]);
			glm::vec3 p3 = glm::vec3(ogre_vertices_tform[ogre_faces[i].z]);
			glm::vec3 face_normal = glm::normalize(
					glm::cross(glm::normalize(p2 - p1), glm::normalize(p3 - p1)));
			
			ogre_vertex_normals[ogre_faces[i].x] += face_normal;
			ogre_vertex_normals[ogre_faces[i].y] += face_normal;
			ogre_vertex_normals[ogre_faces[i].z] += face_normal;
			ogre_vertex_counts[ogre_faces[i].x]++;
			ogre_vertex_counts[ogre_faces[i].y]++;
			ogre_vertex_counts[ogre_faces[i].z]++;
		}

		for (int i = 0; i < ogre_vertices.size(); i++)
			ogre_vertex_normals[i] = ogre_vertex_normals[i] / ogre_vertex_counts[i];

		if (ogre_texture > 0) {
			CHECK_GL_ERROR(glActiveTexture(GL_TEXTURE0));
			CHECK_GL_ERROR(glBindTexture(GL_TEXTURE_2D, textures[ogre_texture-1]));
			CHECK_GL_ERROR(glBindSampler(0, samplers[ogre_texture-1]));		
		}

        CHECK_GL_ERROR(glBindVertexArray(array_objects[kOgreVao]));
      	CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
                	                buffer_objects[kOgreVao][kVertexBuffer]));
    	CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
            	                    sizeof(float) * ogre_vertices_tform.size() * 4, 
        	                        &ogre_vertices_tform[0], GL_STATIC_DRAW));
		CHECK_GL_ERROR(glBindBuffer(GL_ARRAY_BUFFER,
									buffer_objects[kOgreVao][kVertexNormalBuffer]));
		CHECK_GL_ERROR(glBufferData(GL_ARRAY_BUFFER,
	                                sizeof(float) * ogre_vertex_normals.size() * 3,
	                                &ogre_vertex_normals[0], GL_STATIC_DRAW));
 
	    CHECK_GL_ERROR(glUseProgram(ogre_program_id));
        CHECK_GL_ERROR(glUniformMatrix4fv(ogre_projection_matrix_location, 1,
                                          GL_FALSE, &projection_matrix[0][0]));
        CHECK_GL_ERROR(glUniformMatrix4fv(ogre_model_matrix_location, 1,
                                          GL_FALSE, &model_matrix[0][0]));
        CHECK_GL_ERROR(glUniformMatrix4fv(ogre_view_matrix_location, 1,
                                          GL_FALSE, &view_matrix[0][0]));
        CHECK_GL_ERROR(glUniform4fv(ogre_light_position_location, 1, &light_position[0]));
        CHECK_GL_ERROR(glUniform3fv(ogre_c_location, 1, &c[0]));
		CHECK_GL_ERROR(glUniform1f(ogre_ymin_location, ymin));
		CHECK_GL_ERROR(glUniform1f(ogre_ymax_location, ymax));
		CHECK_GL_ERROR(glUniform1i(ogre_sampler_location, 0));
		CHECK_GL_ERROR(glUniform1i(ogre_enable_tex_location, ogre_texture != 0));
		CHECK_GL_ERROR(glDrawElements(GL_TRIANGLES, ogre_faces.size() * 3,
                                      GL_UNSIGNED_INT, 0));
*/

    	/*************************
		 * Poll and swap buffers *
		 *************************/
    	glfwPollEvents();
    	glfwSwapBuffers(window);
  	}
  
	glfwDestroyWindow(window);
  	glfwTerminate();
  	for (int i = 0; i < images.size(); ++i) delete[] images[i].bytes;
  	exit(EXIT_SUCCESS);
}
